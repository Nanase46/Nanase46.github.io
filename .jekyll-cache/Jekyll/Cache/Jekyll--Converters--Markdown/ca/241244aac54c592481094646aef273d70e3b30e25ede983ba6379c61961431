I"ÇA<h1 id="è¯¾åä¹ é¢˜">è¯¾åä¹ é¢˜</h1>

<p>1.ä»€ä¹ˆæ˜¯å¤šé“ç¨‹åºè®¾è®¡ï¼Ÿ<br />
Multiprogramming is the rapid switching of the CPU between multiple processes in memory. It is commonly used to keep the CPU busy while one or more processes are doing I/O.</p>

<p>2.ä»€ä¹ˆæ˜¯SPOOLingï¼Ÿè¯»è€…æ˜¯å¦è®¤ä¸ºå°†æ¥çš„é«˜çº§ä¸ªäººè®¡ç®—æœºä¼šæŠŠSPOOLingä½œä¸ºæ ‡å‡†åŠŸèƒ½ï¼Ÿ<br />
Input spooling is the technique of reading in jobs, for example, from cards, onto the disk, so that when the currently executing processes are finished, there will be work waiting for the CPU. Output spooling consists of first copying printable files to disk before printing them, rather than printing directly as the output is generated. Input spooling on a personal computer is not very likely, but output spooling is.</p>

<p>3.åœ¨æ—©æœŸè®¡ç®—æœºä¸­ï¼Œæ¯ä¸ªå­—èŠ‚çš„è¯»å†™ç›´æ¥ç”±CPUå¤„ç†ï¼ˆå³æ²¡æœ‰DMAï¼‰ã€‚å¯¹äºå¤šé“ç¨‹åºè®¾è®¡è€Œè¨€è¿™ç§ç»„ç»‡æ–¹å¼æœ‰ä»€ä¹ˆå«ä¹‰ï¼Ÿ<br />
The prime reason for multiprogramming is to give the CPU something to do while waiting for I/O to complete. If there is no DMA, the CPU is fully occupied doing I/O, so there is nothing to be gained (at least in terms of CPU utilization) by multiprogramming. No matter how much I/O a program does, the CPU will be 100% busy. This is of course assume the major delay is the wait while data are copied. A CPU could do other work if the I/O were slow for other reasons (arriving on serial line, for instance).</p>

<p>4.ç³»åˆ—è®¡ç®—æœºçš„æ€æƒ³åœ¨20ä¸–çºª60å¹´ä»£ç”±IBMå¼•å…¥è¿›System/360å¤§å‹æœºã€‚ç°åœ¨è¿™ç§æ€æƒ³å·²ç»æ¶ˆäº¡è¿˜æ˜¯ç»§ç»­æ´»è·ƒç€ï¼Ÿ<br />
It is still alive. For example, Intel makes Pentium I, II, and III, and 4 CPUs with a variety of different properites including spped and power consumption.  All of these machines ar architecturally compatible. They differ only in price and perfermance, which is the essence of the family idea.</p>

<p>5.ç¼“æ…¢é‡‡ç”¨GUIçš„ä¸€ä¸ªåŸå› æ˜¯æ”¯æŒå®ƒçš„ç¡¬ä»¶çš„æˆæœ¬ï¼ˆé«˜æ˜‚ï¼‰ã€‚ä¸ºäº†æ”¯æŒ25è¡Œ80åˆ—å­—ç¬¦çš„å•è‰²æ–‡æœ¬å±å¹•åº”è¯¥éœ€è¦å¤šå°‘è§†é¢‘RAMï¼Ÿå¯¹äº1024x768åƒç´ 24ä½è‰²å½©ä½å›¾éœ€è¦å¤šå°‘è§†é¢‘RAMï¼Ÿåœ¨1989å¹´ï¼ˆ$5/KBï¼‰è¿™äº›RAMçš„æˆæœ¬æ˜¯å¤šå°‘ï¼Ÿç°åœ¨å®ƒçš„æˆæœ¬æ˜¯å¤šå°‘ï¼Ÿ<br />
A 25x80 character monochrome text screen requires a 2000-byte buffer. 25<em>80=2000
The 1024x768 pixel 24-bit color bitmap requires 2359296 bytes. 1024</em>768<em>24/8=2359296
In 1980 these two options would have cost $10 and $11520, respectively. 2000</em>5/1024=9.77 2359296*5/1024=11520
For current prices, check on how much RAM currently costs, probably less than $1/MB.</p>

<p>6.åœ¨å»ºç«‹ä¸€ä¸ªæ“ä½œç³»ç»Ÿæ—¶æœ‰å‡ ä¸ªè®¾è®¡ç›®çš„ï¼Œä¾‹å¦‚èµ„æºåˆ©ç”¨ã€åŠæ—¶æ€§ï¼Œå¥å£®æ€§ç­‰ã€‚è¯·åˆ—ä¸¾ä¸¤ä¸ªå¯èƒ½äº’ç›¸çŸ›ç›¾çš„è®¾è®¡ç›®çš„ã€‚<br />
Consider fairness and real time. Fairness requires that each process be allocated it resources in a fair way, with no process getting more than its fair share. On the other hand, real time requires that resources be allocated based on the times when different processes must complete their execution. A real time process may get a disproportionate share of the resources.</p>

<p>7.ä¸‹é¢å“ªä¸€æ¡æŒ‡ä»¤åªèƒ½åœ¨å†…æ ¸æ€ä¸­ä½¿ç”¨ï¼Ÿ<br />
a)ç¦æ­¢æ‰€æœ‰çš„ä¸­æ–­ã€‚
b)è¯»æ—¥æœŸ-æ—¶é—´æ—¶é’Ÿã€‚
c)è®¾ç½®æ—¥æœŸ-æ—¶é—´æ—¶é’Ÿã€‚
d)æ”¹å˜å­˜å‚¨å™¨æ˜ åƒã€‚</p>

<p>acd</p>

<p>8.è€ƒè™‘ä¸€ä¸ªæœ‰ä¸¤ä¸ªCPUçš„ç³»ç»Ÿï¼Œå¹¶ä¸”æ¯ä¸€ä¸ªCPUæœ‰ä¸¤ä¸ªçº¿ç¨‹ï¼ˆè¶…çº¿ç¨‹ï¼‰ã€‚å‡è®¾æœ‰ä¸‰ä¸ªç¨‹åºP0,P1,P2ï¼Œåˆ†åˆ«ä»¥è¿è¡Œæ—¶é—´5ms,10ms,20mså¼€å§‹ã€‚è¿è¡Œè¿™äº›ç¨‹åºéœ€è¦å¤šå°‘æ—¶é—´ï¼Ÿå‡è®¾è¿™ä¸‰ä¸ªç¨‹åºéƒ½æ˜¯100%é™äºCPUï¼Œåœ¨è¿è¡Œæ—¶æ— é˜»å¡ï¼Œå¹¶ä¸”ä¸€æ—¦è®¾å®šå°±ä¸æ”¹å˜CPUã€‚</p>

<p>It may take 20, 25, 30 or 35 msec to complete the execution of these programs
depending on how the operating system schedules them. If P0 and P1 are
scheduled on the same CPU and P2 is scheduled on the other CPU, it will
take 20 mses. If P0 and P2 are scheduled on the same CPU and P1 is
scheduled on the other CPU, it will take 25 msec. If P1 and P2 are scheduled
on the same CPU and P0 is scheduled on the other CPU, it will take 30 msec.
If all three are on the same CPU, it will take 35 msec.</p>

<p>9.ä¸€å°è®¡ç®—æœºæœ‰ä¸€ä¸ªå››çº§æµæ°´çº¿ï¼Œæ¯ä¸€çº§éƒ½èŠ±è´¹ç›¸åŒçš„æ—¶é—´æ‰§è¡Œå…¶å·¥ä½œï¼Œå³1nsã€‚è¿™å°æœºå™¨æ¯ç§’å¯æ‰§è¡Œå¤šå°‘æ¡æŒ‡ä»¤ï¼Ÿ<br />
Every nanosecond one instruction emerges from the pipeline. This means the
machine is executing 1 billion instructions per second. It does not matter at
all how many stages the pipeline has. A 10-stage pipeline with 1 nsec per
stage would also execute 1 billion instructions per second. All that matters is
how often a finished instruction pops out the end of the pipeline.</p>

<p>10.å‡è®¾ä¸€ä¸ªè®¡ç®—æœºç³»ç»Ÿæœ‰é«˜é€Ÿç¼“å­˜ã€å†…å­˜ï¼ˆRAMï¼‰ä»¥åŠç£ç›˜ï¼Œæ“ä½œç³»ç»Ÿç”¨è™šæ‹Ÿå†…å­˜ã€‚è¯»å–ç¼“å­˜ä¸­çš„ä¸€ä¸ªè¯éœ€è¦2nsï¼ŒRAMéœ€è¦10nsï¼Œç£ç›˜éœ€è¦10msã€‚å¦‚æœç¼“å­˜çš„å‘½ä¸­ç‡æ˜¯95%ï¼Œå†…å­˜çš„æ˜¯ï¼ˆç¼“å­˜å¤±æ•ˆï¼‰99%ï¼Œè¯»å–ä¸€ä¸ªè¯çš„å¹³å‡æ—¶é—´æ˜¯å¤šå°‘ï¼Ÿ</p>

<p>Average access time =
0.95 Ã— 2 nsec (word is cache)</p>
<ul>
  <li>0.05 Ã— 0.99 Ã— 10 nsec (word is in RAM, but not in cache)</li>
  <li>0.05 Ã— 0.01 Ã— 10,000,000 nsec (word on disk only)
= 5002.395 nsec
= 5.002395 Î¼sec</li>
</ul>

<p>11.ä¸€ä½æ ¡å¯¹äººå‘˜æ³¨æ„åˆ°åœ¨ä¸€éƒ¨å°†è¦å‡ºç‰ˆçš„æ“ä½œç³»ç»Ÿæ•™ç§‘ä¹¦æ‰‹ç¨¿ä¸­æœ‰ä¸€ä¸ªå¤šæ¬¡å‡ºç°çš„æ‹¼å†™é”™è¯¯ã€‚è¿™æœ¬ä¹¦å¤§è‡´æœ‰700é¡µã€‚æ¯é¡µ50è¡Œï¼Œä¸€è¡Œ80ä¸ªå­—ç¬¦ã€‚è‹¥æŠŠæ–‡ç¨¿ç”¨ç”µå­æ‰«æï¼Œé‚£ä¹ˆï¼Œä¸»å‰¯æœ¬è¿›å…¥å›¾1-9ä¸­çš„æ¯ä¸ªå­˜å‚¨ç³»ç»Ÿçš„å±‚æ¬¡è¦èŠ±è´¹å¤šå°‘æ—¶é—´ï¼Ÿå¯¹äºå†…å­˜å‚¨æ–¹å¼ï¼Œè€ƒè™‘æ‰€ç»™å®šçš„å­˜å–æ—¶é—´æ˜¯æ¯æ¬¡ä¸€ä¸ª1024å­—ç¬¦çš„ç›˜å—ï¼Œè€Œå¯¹äºç£å¸¦ï¼Œå‡è®¾ç»™å®šå¼€å§‹æ—¶é—´åçš„å­˜å–æ—¶é—´å’Œå’Œç£ç›˜å­˜å‚¨æ—¶é—´ç›¸åŒã€‚<br />
The manuscript contains 80 X 50 X 700 = 2.8 million characters. This is, of course, impossible to fit into the registers of any currently available CPU and is too big for a 1-MB cache, but if such hardware were available, the manuscript could be scanned in 2.8 msec ( 2.8 X 10^6 X 10^-9 s) from the registers or 5.8 msec (2.8 X 10^6 X 2 X 10^-9 s) from the cache. There are approximately 2700 ( 2.8 X 10^6 % 1024 = 2735 ) 1024-byte blocks of data, so scanning from the disk would require about 27 seconds (2700 X 10 X 10^-3= 27s ), and from tape 2 minutes 7 senconds 
( 100 + 27 = 127s tapeä¸è€ƒè™‘è¯»å…¥æ—¶çš„æ–‡ä»¶å¤§å°ï¼Ÿ ).</p>

<p>12.**åœ¨ç”¨æˆ·ç¨‹åºè¿›è¡Œä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œä»¥è¯»å†™ç£ç›˜æ–‡ä»¶æ—¶ï¼Œè¯¥ç¨‹åºæä¾›æŒ‡ç¤ºè¯´æ˜äº†æ‰€éœ€è¦çš„æ–‡ä»¶ï¼Œä¸€ä¸ªæŒ‡å‘æ•°æ®ç¼“å†²åŒºçš„æŒ‡é’ˆä»¥åŠè®¡æ•°ã€‚ç„¶åï¼Œæ§åˆ¶æƒè½¬ç»™æ“ä½œç³»ç»Ÿï¼Œå®ƒè°ƒç”¨ç›¸å…³çš„é©±åŠ¨ç¨‹åºã€‚å‡è®¾é©±åŠ¨ç¨‹åºå¯åŠ¨ç£ç›˜å¹¶ä¸”ç›´åˆ°ä¸­æ–­å‘ç”Ÿæ‰ç»ˆæ­¢ã€‚åœ¨ä»ç£ç›˜è¯»çš„æƒ…å†µä¸‹ï¼Œå¾ˆæ˜æ˜¾ï¼Œè°ƒç”¨è€…ä¼šè¢«é˜»å¡ï¼ˆå› ä¸ºæ–‡ä»¶ä¸­æ²¡æœ‰æ•°æ®ï¼‰ã€‚åœ¨å‘ç£ç›˜å†™æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µï¼Ÿéœ€è¦æŠŠè°ƒç”¨è€…é˜»å¡ä¸€ç›´ç­‰åˆ°ç£ç›˜ä¼ é€å®Œæˆä¸ºæ­¢å—ï¼Ÿ<br />
Maybe. If the caller get control back and immediately overwrites the data, when the write finally occurs, the wrong data will be written. However, if the driver first copied the data to a private buffer before returning, then the caller can be allowed to continue immediately. Another possiblity is to allow the caller to continue and give it a singal when the buffer may be used, but this is tricky and error prone.</p>

<p>13.ä»€ä¹ˆæ˜¯é™·é˜±æŒ‡ä»¤ï¼Ÿåœ¨æ“ä½œç³»ç»Ÿä¸­è§£é‡Šå®ƒçš„ç”¨é€”ã€‚<br />
A trap instruction switches the execution mode of a CPU from the user mode to the kernel mode. This instruction allow a user program to invoke functions in the operation system kernel.</p>

<p>14.é™·é˜±å’Œä¸­æ–­çš„ä¸»è¦å·®åˆ«æ˜¯ä»€ä¹ˆï¼Ÿ<br />
A trap is caused by the program and is synchronous with it. If the program is run again and again, the trap will always occur exactly the same position in the instruction stream. An interrupt is caused by an external event and its timing is not reproducible.</p>

<p>15.åœ¨åˆ†æ—¶ç³»ç»Ÿä¸­ä¸ºä»€ä¹ˆéœ€è¦è¿›ç¨‹è¡¨ï¼Ÿåœ¨åªæœ‰ä¸€ä¸ªè¿›ç¨‹å­˜åœ¨çš„ä¸ªäººè®¡ç®—æœºç³»ç»Ÿä¸­ï¼Œè¯¥è¿›ç¨‹æ§åˆ¶æ•´ä¸ªæœºå™¨ç›´åˆ°è¿›ç¨‹ç»“æŸï¼Œè¿™ç§æœºå™¨ä¹Ÿéœ€è¦è¿›ç¨‹è¡¨å—ï¼Ÿ<br />
The process table is needed to store the state of a process that is currently suspended, either ready or blocked. It is not needed in a single process system because the single process is never suspended.</p>

<p>16.è¯´æ˜æœ‰æ²¡æœ‰ç†ç”±è¦åœ¨ä¸€ä¸ªéç©ºçš„ç›®å½•ä¸­å®‰è£…ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿï¼Ÿå¦‚æœè¦è¿™æ ·åšï¼Œå¦‚ä½•åšï¼Ÿ<br />
Mounting a file system makes any files already in the mount point directory inaccessible, so mount points are normally empty. However, a system administrator might want to copy some of the most important files normally located in the mounted directory to the mount point so they could be  found in their noraml path in an emergency when the mounted device was being repaired.</p>

<p>17.åœ¨ä¸€ä¸ªæ“ä½œç³»ç»Ÿä¸­ç³»ç»Ÿè°ƒç”¨çš„ç›®çš„æ˜¯ä»€ä¹ˆï¼Ÿ<br />
A system call allows a user process to access and execute operating system functions indside the kernel. User programs use system calls to invoke operating system services.</p>

<p>18.å¯¹äºä¸‹åˆ—ç³»ç»Ÿè°ƒç”¨ï¼Œç»™å‡ºå¼•èµ·å¤±è´¥çš„æ¡ä»¶ï¼šforkã€execä»¥åŠunlinkã€‚<br />
Fork can fail if there are no free slot left in the process table (and possibley if there is no memory or swap space left).
Exec can fail if the file name given does not exist or is not a valid executable file.
Unlink can fail if the file to be unlinked does not exist or the calling process does not have authority to unlink it.</p>

<p>19.åœ¨count = write(fd, buffer, nbytes);è°ƒç”¨ä¸­ï¼Œèƒ½åœ¨countä¸­è€Œä¸æ˜¯nbytesä¸­è¿”å›å€¼å—ï¼Ÿå¦‚æœèƒ½ï¼Œä¸ºä»€ä¹ˆï¼Ÿ<br />
If the call fails, for example because fd is incorrect, it can return -1. It can also fail because the disk is full and it is not possible to write the number of bytes requested. On a correct termination, it always return nbytes.</p>

<p>20.æœ‰ä¸€ä¸ªæ–‡ä»¶ï¼Œå…¶æ–‡ä»¶æè¿°ç¬¦æ˜¯fdï¼Œå†…å«å­—èŠ‚åºåˆ—ï¼š3,1,4,1,5,9,2,6,5,3,5ã€‚æœ‰å¦‚ä¸‹ç³»ç»Ÿè°ƒç”¨ï¼šlseek(fd,3,SEEK_SET); read(fd,&amp;buffter,4);
å…¶ä¸­lseekè°ƒç”¨å¯»æ‰¾æ–‡ä»¶ä¸­çš„å­—èŠ‚3ã€‚åœ¨è¯»æ“ä½œå®Œæˆåï¼Œbufferä¸­çš„å†…å®¹æ˜¯ä»€ä¹ˆï¼Ÿ<br />
It contains the bytes: 1, 5, 9, 2.</p>

<p>21.å‡è®¾ä¸€ä¸ª10MBçš„æ–‡ä»¶å­˜åœ¨ç£ç›˜è¿ç»­æ‰‡åŒºçš„åŒä¸€ä¸ªè½¨é“ä¸Šï¼ˆè½¨é“å·ï¼š50ï¼‰ã€‚ç£ç›˜çš„ç£å¤´è‡‚æ­¤æ—¶ä½äºç¬¬100å·è½¨é“ã€‚è¦æƒ³ä»ç£ç›˜ä¸Šæ‰¾å›è¿™ä¸ªæ–‡ä»¶ï¼Œéœ€è¦å¤šé•¿æ—¶é—´ï¼Ÿå‡è®¾ç¢°å¤´è‡‚ä»ä¸€ä¸ªæŸ±é¢ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªæŸ±é¢éœ€è¦1msï¼Œå½“æ–‡ä»¶çš„å¼€å§‹éƒ¨åˆ†å­˜å‚¨åœ¨çš„æ‰‡åŒºæ—‹è½¬åˆ°ç£å¤´ä¸‹éœ€è¦5msï¼Œå¹¶ä¸”è¯»çš„é€Ÿç‡æ˜¯100MB/sã€‚<br />
(100-50)*1ms+5ms+10MB/100MB/s=55ms+0.1X10^3ms=155ms</p>

<p>Time to retrieve the file =
1 * 50 ms (Time to move the arm over track # 50)</p>
<ul>
  <li>5 ms (Time for the first sector to rotate under the head)</li>
  <li>10/100 * 1000 ms (Read 10 MB)
= 155 ms</li>
</ul>

<p>22.å—ç‰¹æ®Šæ–‡ä»¶å’Œå­—ç¬¦ç‰¹æ®Šæ–‡ä»¶çš„åŸºæœ¬å·®åˆ«æ˜¯ä»€ä¹ˆï¼Ÿ<br />
Block special files consist of numbered blocks, each of which can be read or written independently of all the other ones. It is possible to seek to any block and start reading and writing. This is not possible with character specical files.</p>

<p>23.åœ¨å›¾1-17çš„ä¾‹å­ä¸­åº“è°ƒç”¨ç§°ä¸ºreadï¼Œè€Œç³»ç»Ÿè°ƒç”¨è‡ªèº«ç§°ä¸ºreadã€‚è¿™ä¸¤è€…éƒ½æœ‰ç›¸åŒçš„åå­—æ˜¯æ­£å¸¸çš„å—ï¼Ÿå¦‚æœä¸æ˜¯ï¼Œå“ªä¸€ä¸ªæ›´é‡è¦ï¼Ÿ<br />
System calls do not really have names, other than in a documentation sence.
When the libray procedure read traps to the kernel, it puts the number of the system call in a register ro on the stack. This number is used to index into a table. There is really no name used anywhere. On the other hand, the name of the library procedure is very import, since this is what appears in the program.</p>

<p>24.åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œå®¢æˆ·æœº-æœåŠ¡å™¨æ¨¡å¼å¾ˆæ™®éã€‚è¿™ç§æ¨¡å¼èƒ½ç”¨åœ¨å•ä¸ªè®¡ç®—æœºçš„ç³»ç»Ÿä¸­å—ï¼Ÿ<br />
Yes it can, especially if the kernel is message-passing system.</p>

<p>25.å¯¹äºç¨‹åºå‘˜è€Œè¨€ï¼Œç³»ç»Ÿè°ƒç”¨å°±åƒå¯¹å…¶ä»–åº“è¿‡ç¨‹çš„è°ƒç”¨ä¸€æ ·ã€‚æœ‰æ— å¿…è¦è®©ç¨‹åºå‘˜äº†è§£å“ªä¸€ä¸ªåº“è¿‡ç¨‹å¯¼è‡´äº†ç³»ç»Ÿè°ƒç”¨ï¼Ÿåœ¨ä»€ä¹ˆæƒ…å½¢ä¸‹ï¼Œä¸ºä»€ä¹ˆï¼Ÿ<br />
As far as program logic is concerned it does not matter whether a call to a library procedure results in a system call. But if perfermance is an issue, if a task can be accomplished without  a system call the program will run faster. Every system call involves overhead time in switching from the user context to the kernel context. Furthermore, on a multiuser system the operatiing system may schedule another process o run when a system call completes, further slowing the progress in real time of a calling process.</p>

<p>26.å›¾1-23è¯´æ˜æœ‰ä¸€æ‰¹UNIXçš„ç³»ç»Ÿè°ƒç”¨æ²¡æœ‰ä¸ä¹‹ç›¸ç­‰ä»·çš„Win32 APIã€‚å¯¹äºæ‰€åˆ—å‡ºçš„æ¯ä¸€ä¸ªæ²¡æœ‰Win32ç­‰ä»·çš„è°ƒç”¨ï¼Œè‹¥ç¨‹åºå‘˜è¦æŠŠä¸€ä¸ªUNIXç¨‹åºè½¬æ¢åˆ°Windowsä¸‹è¿è¡Œï¼Œä¼šæœ‰ä»€ä¹ˆåæœï¼Ÿ<br />
Serval UNIX calls have no counterpart in the Win32 API:
Link: a Win32 program cannot refer to a file by an alternative name or see it in more than one directory. Also, attempting to create a link is a convenient way to test fro and create a lock on a file.
Mount and umount: a Windows program cannot make assumptions about standard path names because on systems with multiple disk drives the drive name  part of the path may be different.
Chmod: Windows uses access control lists
Kill: Windows programmers cannot kill a misbehaving program that is not cooperating.</p>

<p>27.å¯ç§»æ¤çš„æ“ä½œç³»ç»Ÿæ˜¯èƒ½ä»ä¸€ä¸ªç³»ç»Ÿä½“ç³»ç»“æ„åˆ°å¦ä¸€ä¸ªä½“ç³»ç»“æ„çš„ç§»åŠ¨ä¸éœ€è¦ä»»ä½•ä¿®æ”¹çš„æ“ä½œç³»ç»Ÿã€‚è¯·è§£é‡Šä¸ºä»€ä¹ˆå»ºç«‹ä¸€ä¸ªå®Œå…¨å¯ç§»æ¤æ€§çš„æ“ä½œç³»ç»Ÿæ˜¯ä¸å¯è¡Œçš„ã€‚æè¿°ä¸€ä¸‹åœ¨è®¾è®¡ä¸€ä¸ªé«˜åº¦å¯ç§»æ¤çš„æ“ä½œç³»ç»Ÿæ—¶ä½ è®¾è®¡çš„é«˜çº§çš„ä¸¤å±‚æ˜¯ä»€ä¹ˆæ ·çš„ã€‚<br />
Every system architecture has its own set of instructions that it can execute. Thus a Pentumn cannot excute SPARC programs and SPARC cannot execute Pentium programs. Also, different architectures differ in bus architecture used (such as VME, ISA, PCI, MCA, SBus, ..) as well as the word size of the CPU (usually 32 or 64 bit). Because of these differences in hardware, it is not feasible to build an operating system that is completely portable. A highly portable operating system will consist of two high-level layersâ€”a machine-dependent layer and a machine independent layer.
The machine-dependent layer addresses the specifics of the hardware, and must be implemented separately for every architecture. This layer provides a uniform interface on which the machine-independent layer is built. The machine-independent layer has to be implemented only onece. To be highly protable, the size of the machine-dependent layer must be kept as small as possible.</p>

<p>28.è¯·è§£é‡Šåœ¨å»ºç«‹åŸºäºå¾®å†…æ ¸çš„æ“ä½œç³»ç»Ÿæ—¶ç­–ç•¥ä¸æœºåˆ¶çš„åˆ†ç¦»å¸¦æ¥çš„å¥½å¤„ã€‚<br />
Separation of policy and mechanism allows OS designers to implement a small number of basic primitives in the kernel. These primitives are simpified, because they are not dependent of any specific policy. They can then be used to implement more complex mechanisms and policies at the user level.</p>

<p>29.ä¸‹é¢æ˜¯å•ä½è½¬æ¢çš„ç»ƒä¹ ï¼š<br />
a)ä¸€å¾®å¹´æ˜¯å¤šå°‘ç§’ï¼Ÿ<br />
b)å¾®ç±³å¸¸ç§°ä¸ºmicronã€‚é‚£ä¹ˆgigamicronæ˜¯å¤šé•¿ï¼Ÿ<br />
c)1TBå­˜å‚¨å™¨æœ‰å¤šå°‘å­—èŠ‚ï¼Ÿ<br />
d)åœ°çƒçš„è´¨é‡æ˜¯6000yottagramï¼Œæ¢ç®—æˆkilogramæ˜¯å¤šå°‘ï¼Ÿ</p>

<p>a) A micro year is 10^-6 X 365 X 24 X 3600 = 31.536 sec.<br />
b) 10^9*10^-6=1000m<br />
c) 2^10 X 2^10 X 2^10 X 2^10 = 2^40 Bytes<br />
d) 6000 X 10^24 X 10^-3 = 6 X 10^24 kilogram</p>

<p>30.å†™ä¸€ä¸ªå„å›¾1-19ç±»ä¼¼çš„shellï¼Œä½†æ˜¯åŒ…å«è¶³å¤Ÿçš„å®é™…å¯å·¥ä½œçš„ä»£ç ï¼Œè¿™æ ·è¯»è€…å¯ä»¥æµ‹è¯•å®ƒã€‚è¯»è€…è¿˜å¯ä»¥æ·»åŠ æŸäº›åŠŸèƒ½ï¼Œå¦‚è¾“å…¥è¾“å‡ºé‡å®šå‘ã€ç®¡é“ä»¥åŠåå°ä½œä¸šç­‰ã€‚</p>

<p>31.å¦‚æœè¯»è€…æ‹¥æœ‰ä¸€ä¸ªä¸ªäººUNIXç±»æ“ä½œç³»ç»Ÿï¼ˆLinux/MINIX/FreeBSDç­‰ï¼‰ï¼Œå¯ä»¥å®‰å…¨åœ°å´©æºƒå’Œå†å¯åŠ¨ï¼Œè¯·å†™ä¸€ä¸ªå¯ä»¥è¯•å›¾åˆ›å»ºä¸€ä¸ªæ— é™åˆ¶æ•°é‡å­è¿›ç¨‹çš„shellè„šæœ¬å¹¶è§‚å¯Ÿæ‰€å‘ç”Ÿçš„äº‹ã€‚åœ¨è¿è¡Œå®éªŒä¹‹å‰ ï¼Œé€šè¿‡shellé”®å…¥syncï¼Œåœ¨ç£ç›˜ä¸Šå¤‡ä»½å¥½æ–‡ä»¶ç¼“å†²åŒºä»¥é¿å…æ¯åæ–‡ä»¶ç³»ç»Ÿã€‚ï¼ˆæ³¨æ„ï¼šåœ¨æ²¡æœ‰å¾—åˆ°ç³»ç»Ÿç®¡ç†å‘çš„å…è®¸ä¹‹å‰ï¼Œä¸è¦åœ¨åˆ†æ—¶ç³»ç»Ÿä¸Šè¿›è¡Œè¿™ä¸€å°è¯•ã€‚å…¶åæœå°†ä¼šç«‹å³å‘ç”Ÿï¼Œå°è¯•è€…å¯èƒ½ä¼šè¢«æŠ“ä½å¹¶å—åˆ°æƒ©ç½šã€‚ï¼‰</p>

<p>32.ç”¨ä¸€ä¸ªç±»ä¼¼äºUNIX odæˆ–MS-DOS DEBUGçš„ç¨‹åºè€ƒå¯Ÿå¹¶å°è¯•è§£é‡ŠUNIXç±»ç³»ç»Ÿæˆ–Windowsçš„ç›®å½•ã€‚æç¤ºï¼šå¦‚ä½•è¿›è¡Œå–å†³äºOSå…è®¸åšä»€ä¹ˆã€‚ä¸€ä¸ªæœ‰ç›Šçš„æŠ€å·§æ˜¯åœ¨ä¸€ä¸ªæœ‰æŸä¸ªæ“ä½œç³»ç»Ÿçš„è½¯ç›˜ä¸Šåˆ›å»ºä¸€ä¸ªç›®å½•ï¼Œç„¶åä½¿ç”¨ä¸€ä¸ªå…è®¸è¿›è¡Œæ­¤ç±»çš„è®¿é—®çš„ä¸åŒçš„æ“ä½œç³»ç»Ÿè¯»ç›˜ä¸Šçš„åŸå§‹æ•°æ®ã€‚</p>

<h1 id="ref">Ref</h1>
<p><a href="http://www.cnblogs.com/wuyuegb2312/p/3369082.html">ã€Šç°ä»£æ“ä½œç³»ç»Ÿã€‹ç²¾è¯»ä¸æ€è€ƒç¬”è®° ç¬¬ä¸€ç«  å¼•è®º</a></p>

:ET